# 指针/引用/内存

内存布局

```sh
0x5ffdc0 80 8c 70 00   00 00 00 00   33 00 00 00   00 00 00 00
...
0x708c80 32 20 c6 33   43 0a ed 8f   f9 df bd c7   ee 90 2d 52
```

| 变量值            |                                                 | val                     |
| ----------------- | ----------------------------------------------- | ----------------------- |
| str               | 80 8c 70 00 00 00 00 00 33 00 00 00 00 00 00 00 |
| &str              | 0x5fdc0                                         |
| `(uint64_t *)str` | 0x788c80                                        | 32 20 c6 33 43 0a ed 8f |
| `(uint32_t *)str` | 0x788c80                                        | 32 20 c6 33             |

# functions

## strcmp(s1, s2)

当 s1<s2 时，返回为负数；
当 s1=s2 时，返回值= 0；
当 s1>s2 时，返回正数。 [2]

if !(strcmp(s1, s2)) --> s1 == s2 时 echo
echo

## read(int fd, void \*buf, size_t count)

成功返回读取的字节数，出错返回-1 并设置 errno，如果在调 read 之前已到达文件末尾，则这次 read 返回 0。

## fd

| fd  | 文件指针                |
| --- | ----------------------- |
| 0   | stdin                   |
| 1   | stdout                  |
| 2   | stderr                  |
| 3   | Test.py - 通常由 3 开始 |

### dup/dup2

dup 用来复制参数 oldfd 所指的文件描述符。当复制成功是，返回最小的尚未被使用过的文件描述符，若有错误则返回-1.错误代码存入 errno 中返回的新文件描述符和参数 oldfd 指向同一个文件，这两个描述符共享同一个数据结构，共享所有的锁定，读写指针和各项全现或标志位。

```
#include <unistd.h>
int dup2(int oldfd, int newfd);
```

dup2 与 dup 区别是 dup2 可以用参数 newfd 指定新文件描述符的数值。若参数 newfd 已经被程序使用，则系统就会将 newfd 所指的文件关闭，若 newfd 等于 oldfd，则返回 newfd,而不关闭 newfd 所指的文件。dup2 所复制的文件描述符与原来的文件描述符共享各种文件状态。共享所有的锁定，读写位置和各项权限或 flags 等.

返回值： 若 dup2 调用成功则返回新的文件描述符，出错则返回-1.
